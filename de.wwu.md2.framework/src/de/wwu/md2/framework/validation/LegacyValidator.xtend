package de.wwu.md2.framework.validation

import com.google.common.collect.Maps
import com.google.common.collect.Sets
import com.google.inject.Inject
import de.wwu.md2.framework.mD2.AbstractViewGUIElementRef
import de.wwu.md2.framework.mD2.AlternativesPane
import de.wwu.md2.framework.mD2.AutoGeneratedContentElement
import de.wwu.md2.framework.mD2.ContainerElement
import de.wwu.md2.framework.mD2.ContainerElementReference
import de.wwu.md2.framework.mD2.ContentElement
import de.wwu.md2.framework.mD2.ContentProvider
import de.wwu.md2.framework.mD2.ContentProviderAddAction
import de.wwu.md2.framework.mD2.ContentProviderPath
import de.wwu.md2.framework.mD2.ContentProviderReference
import de.wwu.md2.framework.mD2.ContentProviderRemoveAction
import de.wwu.md2.framework.mD2.Controller
import de.wwu.md2.framework.mD2.DataType
import de.wwu.md2.framework.mD2.EntitySelector
import de.wwu.md2.framework.mD2.FilterType
import de.wwu.md2.framework.mD2.FlowLayoutPane
import de.wwu.md2.framework.mD2.GridLayoutPane
import de.wwu.md2.framework.mD2.GridLayoutPaneColumnsParam
import de.wwu.md2.framework.mD2.GridLayoutPaneParam
import de.wwu.md2.framework.mD2.GridLayoutPaneRowsParam
import de.wwu.md2.framework.mD2.ListView
import de.wwu.md2.framework.mD2.MD2Model
import de.wwu.md2.framework.mD2.MD2Package
import de.wwu.md2.framework.mD2.Main
import de.wwu.md2.framework.mD2.ReferencedModelType
import de.wwu.md2.framework.mD2.SimpleType
import de.wwu.md2.framework.mD2.Spacer
import de.wwu.md2.framework.mD2.StandardValidator
import de.wwu.md2.framework.mD2.TabSpecificParam
import de.wwu.md2.framework.mD2.TabbedAlternativesPane
import de.wwu.md2.framework.mD2.Validator
import de.wwu.md2.framework.mD2.ViewElementType
import de.wwu.md2.framework.mD2.ViewGUIElement
import de.wwu.md2.framework.mD2.ViewGUIElementReference
import de.wwu.md2.framework.mD2.WidthParam
import de.wwu.md2.framework.util.MD2Util
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

public class LegacyValidator extends AbstractMD2Validator {

	@Inject
	private ValidatorHelpers helper;

	@Inject
	private MD2Util util;

	/////////////////////////////////////////////////////////
	/// View layer
	/////////////////////////////////////////////////////////

	/**
	 * Prevent from defining parameters multiple times in any of the view ContainerElements.
	 *
	 * @param containerElement
	 */
	@Check
	def checkRepeatedParams(ContainerElement containerElement) {
		
		// TabbedAlternativesPane and ListView are container elements without parameters
		if(containerElement instanceof TabbedAlternativesPane || containerElement instanceof ListView) {

			return;
		}

		helper.repeatedParamsError(containerElement, MD2Package.eINSTANCE.getViewElement_Name(), this,
				"GridLayoutPaneRowsParam", "rows", "GridLayoutPaneColumnsParam", "columns",
				"FlowLayoutPaneFlowDirectionParam", "horizontal | vertical",
				"MultiPaneObjectParam", "object", "MultiPaneTextPropositionParam", "textProposition",
				"MultiPaneDisplayAllParam", "displayAll",
				"TabTitleParam", "tabTitle", "TabIconParam", "tabIcon", "TabStaticParam", "static");
	}

	/**
	 * Ensure that tab-specific parameters are only assigned to elements within a tabbed pane.
	 *
	 * @param tabSpecificParam
	 */
	@Check
	def ensureThatTabParamsOnlyInTabContainer(TabSpecificParam tabSpecificParam) {

		var obj = tabSpecificParam.eContainer();
		while (!(obj instanceof TabbedAlternativesPane) && obj !== null) {
			obj = obj.eContainer()
		}

		// if no parent container of type tabbed pane found
		if(obj === null) acceptWarning("Specifiying a tab-specific parameter outside of a tabbed pane has no effect.", tabSpecificParam, null, -1, null);
	}

	/**
	 * Prevent from defining parameters multiple times in any of the references.
	 *
	 * @param containerRef
	 */
	@Check
	def checkRepeatedParams(ContainerElementReference containerRef) {
		helper.repeatedParamsError(containerRef, null, this, "TabTitleParam", "tabTitle", "TabIconParam", "tabIcon");
	}

	/**
	 * Checks whether a grid layout defines at least the 'rows' or the 'columns' parameter.
	 *
	 * @param gridLayoutPane GridLayout to be checked.
	 */
	@Check
	def checkThatRowsOrColumnsParamIsSet(GridLayoutPane gridLayoutPane) {

		for(GridLayoutPaneParam param : gridLayoutPane.getParams()) {
			if(param instanceof GridLayoutPaneColumnsParam || param instanceof GridLayoutPaneRowsParam) {
				return;
			}
		}

		acceptError("At least the 'rows' or the 'columns' parameter has to be specified.", gridLayoutPane, null, -1, null);
	}

	/**
	 * Checks if the grid layout contains more than 'rows'x'columns' elements.
	 *
	 * @param gridLayoutPane GridLayout to be checked.
	 */
	@Check
	def checkWhetherGridLayoutSizeFits(GridLayoutPane gridLayoutPane) {

		var columns = -1;
		var rows = -1;

		for(GridLayoutPaneParam param : gridLayoutPane.getParams()) {
			if(param instanceof GridLayoutPaneColumnsParam) {
				columns = param.getValue();
			}
			else if(param instanceof GridLayoutPaneRowsParam) {
				rows = param.getValue();
			}
		}

		// calculate total number of elements in grid layout
		var size = 0;
		for(ViewElementType e : gridLayoutPane.getElements()) {
			if(e instanceof Spacer && (e as Spacer).getNumber() > 1) {
				size += (e as Spacer).getNumber();
			} else {
				size++;
			}
		}

		// both parameters are set and there are too few cells for all elements to fit in
		if(columns != -1 && rows != -1 && size > columns * rows) {
			acceptWarning("The grid layout contains more than 'rows'x'columns' elements: " +
					"The grid has " + columns * rows +" cells, but contains " + size + " elements. " +
					"All elements that do not fit in the grid will be omitted.", gridLayoutPane, null, -1, null);
		}
	}

	/**
	 * This validator avoids the reuse of an element (via reference) multiple times without renaming.
	 *
	 * @param ref
	 */
	@Check
	def avoidReuseOfElementWithoutRenamingGeneric(ContainerElement container) {

		val Map<String, Map<Boolean, Set<EObject>>> refrencedObjName = Maps.newHashMap();

		// iterate over all references in the container and store their names in a hash map
		// collect duplicate elements
		val Set<EObject> elements = getElementsOfContainerElement(container)
		elements.filter(ViewGUIElementReference).forEach[elem | 
			var guiElement = elem.getValue();
			var isRenamed = elem.isRename();
			var renameName = elem.getName();

			// remember all objects in corresponding sets (name -> isRename => set of corresponding elements)
			val name = if(isRenamed) { renameName } else { guiElement.getName() }
			if(!refrencedObjName.keySet().contains(name)) {
				val Map<Boolean, Set<EObject>> map = Maps.newHashMapWithExpectedSize(2);
				map.put(true, Sets.<EObject>newHashSet());
				map.put(false, Sets.<EObject>newHashSet());
				refrencedObjName.put(name, map);
			}
			refrencedObjName.get(name).get(isRenamed).add(elem);
		]

		// generate errors if more than one object for a certain name is stored
		for (Map<Boolean, Set<EObject>> map : refrencedObjName.values()) {
			if(map.get(false).size() + map.get(true).size() > 1) {
				for (EObject obj : map.get(false)) {
					acceptError("The same reference has been used multiple times without renaming (use '->' operator).", obj, null, -1, null);
				}
				for (EObject obj : map.get(true)) {
					acceptError("The renamed GUI element has the same name as a referenced GUI element in the same scope.", obj, null, -1, null);
				}
			}
		}
	}

	@Check
	def checkEntitySelectorContentProviderIsMany(ContentProviderPath contentProviderPathDefinition) {
		if (contentProviderPathDefinition.eContainer() instanceof EntitySelector) {
			if (contentProviderPathDefinition.getContentProviderRef() !== null) {
				val cp =  contentProviderPathDefinition.getContentProviderRef();
				if (!cp.getType().isMany()) {
					error("The selected ContentProvider is not compatible. Check multiplicities!", MD2Package.eINSTANCE.getContentProviderPath_ContentProviderRef());
				}
			}
		}
	}

	/**
	 * Checks the width attribute of all GUI elements. If the value is 0% or greater than 100% an error is thrown. The default value for the width as
	 * specified in the model (via MD2PostProcessor) is -1, so that the error is only shown if the user set this optional attribute explicitly.
	 *
	 * @param guiElement
	 */
	@Check
	def checkViewGUIElementWidthIsGreaterZeroAndLessOrEqualThanHundret(ViewGUIElement guiElement) {
		if (guiElement instanceof ContentElement) {
			val width = guiElement.getWidth();
			if (width < 0 || width > 100) {
				error("The width parameter may not be " + width + "%. Please set a value between 1% and 100%.", MD2Package.eINSTANCE.getContentElement_Width());
			}
		} else if (guiElement instanceof ContainerElement) {
			// get width parameter from container element
			for (EObject param : getParametersOfContainerElement(guiElement)) {
				if(param instanceof WidthParam) {
					val width = param.getWidth();
					if (width == 0 || width > 100) {
						acceptError("The width parameter may not be " + width + "%. Please set a value between 1% and 100%.", param, null, -1, null);
					}
				}
			}
		}
	}

	/////////////////////////////////////////////////////////
	/// Controller layer
	/////////////////////////////////////////////////////////

	/**
	 * This validator enforces the declaration of exactly one Main block in each of the
	 * controller files.
	 *
	 * @param controller
	 */
	@Check
	def ensureThatExactlyOneMainBlockExists(Controller controller) {

		// this list only stores the Main objects of the controller currently validated
		// this information is needed to mark all duplicate Main blocks
		var List<Main> mainObjects = null;

		// this counter stores the overall occurrences of main blocks throughout all controllers
		var occurencesOfMain = 0;

		// collect all Main Objects of this controller and count the overall main objects over all controllers
		val md2Models = util.getAllMD2Models(controller.eResource());
		for(MD2Model m : md2Models) {
			val ml = m.getModelLayer();
			if(ml instanceof Controller) {
				val lst = EcoreUtil2.getAllContentsOfType(ml, Main);
				occurencesOfMain += lst.size();

				if(ml.eResource().getURI().equals(controller.eResource().getURI())) {
					mainObjects = lst;
				}
			}
		}

		// throw error if not exactly one main block exists
		if(occurencesOfMain == 0 && !md2Models.isEmpty()) {
			error("The Main declaration block is missing", MD2Package.eINSTANCE.getController_ControllerElements());
		} else if(occurencesOfMain > 1 && mainObjects !== null) {
			// mark all Main blocks in this controller
			for(Main mainObj : mainObjects) {
				acceptError("Only one Main block is allowed, but " + occurencesOfMain + " have been found", mainObj, null, -1, null);
			}
		}
	}

	/**
	 * Prevent from defining parameters multiple times in any of the validators.
	 *
	 * @param validator
	 */
	@Check
	def checkRepeatedParams(Validator validator) {
		helper.repeatedParamsError(validator, MD2Package.eINSTANCE.getValidator_Name(), this, validatorParams());
	}

	/**
	 * Prevent from defining parameters multiple times in any of the standard validators.
	 *
	 * @param validator
	 *
	 */
	@Check
	def checkRepeatedParams(StandardValidator validator) {
		helper.repeatedParamsError(validator, MD2Package.eINSTANCE.getStandardValidator_Params(), this, validatorParams());
	}

	private def String[] validatorParams() {
		return #[
			"ValidatorMessageParam", "message",
			"ValidatorFormatParam", "format",
			"ValidatorRegExParam", "regEx",
			"ValidatorMaxParam", "max", "ValidatorMinParam", "min",
			"ValidatorMaxLengthParam", "maxLenght", "ValidatorMinLengthParam", "minLength"
		]
	}

	/**
	 * Make sure the the ContentProviderPathDefinition for a ReferencedModelType-ContentProvider provides at least one attribute
	 * Mainly used for MappingTasks.
	 * @param pathDef
	 */
	@Check
	def checkContentProviderPathDefinition(ContentProviderPath pathDef) {
		if (pathDef.getContentProviderRef() !== null) {
			if (pathDef.getContentProviderRef().getType() instanceof ReferencedModelType) {
				if (pathDef.getTail() === null) {
					error("No attribute specified", MD2Package.eINSTANCE.getContentProviderPath_ContentProviderRef());
				}
			}
		}
	}

	/**
	 * Make sure the referenced auto-generated element from a Simple-Type-ContentProvider exists
	 * @param abstractRef
	 */
	@Check
	def checkAbstractViewGUIElementRef_SimpleDataType(AbstractViewGUIElementRef abstractRef) {
		if (abstractRef.getSimpleType() === null) return;
		val simpleTypes = newArrayList();
		if (abstractRef.getRef() instanceof AutoGeneratedContentElement) {
			for (ContentProviderReference ref : (abstractRef.getRef() as AutoGeneratedContentElement).getContentProvider()) {
				val cp = ref.getContentProvider();
				if (cp.getType() instanceof SimpleType) {
					val type = (cp.getType() as SimpleType).getType();
					if (type == abstractRef.getSimpleType().getType()){ return }
					else simpleTypes.add(type.toString());
				}
			}
		}
		var warning = "No such element exists.";
		if (simpleTypes.size() > 0) warning += " Choose from: " + simpleTypes;
		error(warning, MD2Package.eINSTANCE.getAbstractViewGUIElementRef_SimpleType());
	}

	/**
	 * Prevent user from referencing an AutoGeneratorContentElement
	 * @param abstractRef
	 */
	@Check
	def checkAbstractViewGUIElementRef_Path(AbstractViewGUIElementRef abstractRef) {
		if (abstractRef.getRef() instanceof AutoGeneratedContentElement && abstractRef.getPath() === null && abstractRef.getSimpleType() === null) {
			warning("No attribute specified.", MD2Package.eINSTANCE.getAbstractViewGUIElementRef_Path());
		}
	}

	/**
	 * This validator avoids the assignment of none-toMany content providers (providing X[]) to ContentProviderAddActions.
	 * @param addAction
	 */
	@Check
	def checkForAssignmentsOfSingleElementContentProvidersToContentProviderAddActions(ContentProviderAddAction addAction) {

		val contentProvider = addAction.getContentProviderTarget().getContentProvider();

		if(!contentProvider.getType().isMany()) {
			acceptError("Tried to add an element to a content provider of type '" + getDataTypeName(contentProvider.getType())
					+ "', but expected an is-many content provider " + getDataTypeName(contentProvider.getType()) + "[].",
					addAction, MD2Package.eINSTANCE.getContentProviderAddAction_ContentProviderTarget(), -1, null);
		}

		 val sp = addAction.getContentProviderSource().getContentProvider();

		 if(sp.getType().isMany()) {
				acceptError("Tried to use a MultiContentProvider as source for addAction, only single ContenProvider allowed",
						addAction, MD2Package.eINSTANCE.getContentProviderAddAction_ContentProviderSource(), -1, null);
			}

	}

	/**
	 * This validator avoids the assignment of none-toMany content providers (providing X[]) to ContentProviderRemoveActions.
	 * @param removeAction
	 */
	@Check
	def checkForAssignmentsOfSingleElementContentProvidersToContentProviderRemoveActions(ContentProviderRemoveAction removeAction) {

		val contentProvider = removeAction.getContentProvider().getContentProvider();

		if(!contentProvider.getType().isMany()) {
			acceptError("Tried to remove an element from a content provider of type '" + getDataTypeName(contentProvider.getType())
					+ "', but expected an is-many content provider " + getDataTypeName(contentProvider.getType()) + "[].",
					removeAction, MD2Package.eINSTANCE.getContentProviderRemoveAction_ContentProvider(), -1, null);
		}
	}

	public static final String FILTERMULTIPLIYITY = "filtermultipliyity";

	/**
	 * Avoid the assignment of 'all' filters to single-instance content providers.
	 * @param contentProvider
	 */
	@Check
	def checkFilterMultiplicity(ContentProvider contentProvider) {
		if(!contentProvider.getType().isMany() && contentProvider.isFilter() && contentProvider.getFilterType().equals(FilterType.ALL)) {
			acceptError("The filter type 'all' cannot be assigned to content providers that only return a single " +
				"instance. Change parameter to 'first'.", contentProvider, MD2Package.eINSTANCE.getContentProvider_FilterType(), -1, FILTERMULTIPLIYITY);
		}
	}


	/////////////////////////////////////////////////////////
	/// Private helpers
	/////////////////////////////////////////////////////////

	private def Set<EObject> getElementsOfContainerElement(ContainerElement container) {

		val elements = newHashSet();

		if(container instanceof GridLayoutPane) {
			elements.addAll(container.getElements());
		} else if(container instanceof FlowLayoutPane) {
			elements.addAll(container.getElements());
		} else if(container instanceof AlternativesPane) {
			elements.addAll(container.getElements());
		} else if(container instanceof TabbedAlternativesPane) {
			elements.addAll(container.getElements());
		} else if(container instanceof ListView){
			elements.addAll(container.getElements());
		} else {
			System.err.println("Unexpected ContainerElement subtype found: " + container.getClass().getName());
		}

		return elements;
	}

	private def Set<EObject> getParametersOfContainerElement(ContainerElement container) {

		val parameters = newHashSet();

		if(container instanceof GridLayoutPane) {
			parameters.addAll(container.getParams());
		} else if(container instanceof FlowLayoutPane) {
			parameters.addAll(container.getParams());
		} else if(container instanceof AlternativesPane) {
			parameters.addAll(container.getParams());
		} else if(container instanceof TabbedAlternativesPane) {
			// has no parameters
		} else if(container instanceof ListView) {
			// has no used parameters
		} else {
			System.err.println("Unexpected ContainerElement subtype found: " + container.getClass().getName());
		}

		return parameters;
	}

	private def String getDataTypeName(DataType dataType) {

		var str = "";

		if(dataType instanceof ReferencedModelType) {
			str = dataType.getEntity().getName();
		} else if(dataType instanceof SimpleType) {
			str = dataType.getType().getLiteral();
		} else {
			System.err.println("Unexpected DataType found: " + dataType.getClass().getName());
		}

		return str;
	}

}
